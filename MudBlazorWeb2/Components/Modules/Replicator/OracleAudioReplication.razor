@*OracleAudioReplication.razor*@

@using Oracle.ManagedDataAccess.Client
@using Oracle.ManagedDataAccess.Types

@using Microsoft.EntityFrameworkCore
@using FFMpegCore
@using System.Diagnostics
@using System.Text.Json

@using MudBlazorWeb2.Components.Classes
@using MudBlazorWeb2.Components.Modules.Replicator
@using MudBlazorWeb2.Components.EntityFrameworkCore



<MudButton OnClick="@(e => StartReplication())" ButtonType="ButtonType.Submit" Variant="Variant.Outlined" Color="@colorButton">Пуск!</MudButton>

<MudSimpleTable Hover="true" Dense="true" FixedHeader="true" Style="height:200px;">
    <thead>
        <tr>
            <th>Прогресс:</th>
            <th>Сообщение:</th>
        </tr>
    </thead>
    <tbody>
            <tr>
                <td>@progress</td>
                <td>@message</td>
            </tr>
    </tbody>
</MudSimpleTable>


@code {
    [Parameter]
    public string pathToSaveTempAudio { get; set; }
    [Parameter]
    public string nameConfigFile { get; set; }
    [Parameter]
    public string sourceName { get; set; }
    [Parameter]
    public MudBlazor.Color colorButton { get; set; }
    //[Parameter]
    //public OracleDbContext DbContext { get; set; }

    OraSettings settings = new OraSettings();

    string conStringDBA = "";
    string Scheme = "";

    private string ffmpegExePath = @"C:\dotnet\ffmpeg\ffmpeg.exe";
    private int currentProgress = 0;
    private int durationOfWav = 0;
    private string message = "";
    private string progress = "";

    Operations operations = new Operations();

    protected override async Task OnInitializedAsync()
    {
        await LoadSettingsFromFile();
    }

    private async Task LoadSettingsFromFile()
    {
        string json = await File.ReadAllTextAsync(nameConfigFile);
        settings = JsonSerializer.Deserialize<OraSettings>(json);
        conStringDBA = settings.ReplOraString.OracleDbConnectionString;
        Scheme = settings.ReplOraString.Scheme;
    }

    // если стерео => _left + _right, если моно => _mono для БД с кодеком pcm_alaw ; потом + .wav для whisper с кодеком pcm_s16le


    private async Task StartReplication()
    {
        await LoadSettingsFromFile();

        message = "";
        progress = "";

        string[] files = Directory.GetFiles(pathToSaveTempAudio);

        try
        {

            using (var context = new OracleDbContext(new DbContextOptionsBuilder<OracleDbContext>().UseOracle(conStringDBA).Options))
            {
                await context.Database.OpenConnectionAsync();
                if (await context.Database.CanConnectAsync())
                    message += "EFCore: Соединение с Oracle установлено!\n";
                Console.WriteLine("EFCore: Соединение с Oracle установлено!");

                await context.Database.ExecuteSqlRawAsync($"ALTER SESSION SET CURRENT_SCHEMA = {Scheme}");
                message += $"Выбранная схема: {Scheme} ";
                Console.WriteLine($"Выбранная схема: {Scheme}");

                int filesCount = files.Count();
                int currentFileNum = 0;

                foreach (var filePath in files)
                {
                    currentFileNum++;
                    progress = currentFileNum + " / " + filesCount;
                    try
                    {
                        long maxKey = await context.SprSpeechTable.MaxAsync(x => x.Id);
                        Console.WriteLine("maxKey: " + maxKey);

                        var fileData = new { Timestamp = DateTime.Now, IMEI = "", Caller = "", Talker = "", Calltype = 2 };
                        //var fileData = AudioMethods.ParseFileName(filePath);

                        await RunFFmpeg(filePath);

                        byte[]? fileDataLeft = File.Exists(filePath + "_left.wav") ? File.ReadAllBytes(filePath + "_left.wav") : null;
                        //OracleDbType oracleDbType = OracleDbType.Blob;
                        
                        if (fileDataLeft == null) fileDataLeft = File.Exists(filePath + "_mono.wav") ? File.ReadAllBytes(filePath + "_mono.wav") : null;
                        byte[]? fileDataRight = File.Exists(filePath + "_right.wav") ? File.ReadAllBytes(filePath + "_right.wav") : null;

                        if (fileDataLeft != null)
                        {
                            var speechTableEntry = new SPR_SPEECH_TABLE
                                {
                                    Id = maxKey + 1,
                                    Type = 0,
                                    Prelooked = 0,
                                    Deviceid = "MEDIUM_R",
                                    Datetime = fileData.Timestamp,
                                    Duration = string.Format("+00 {0:D2}:{1:D2}:{2:D2}.000000", durationOfWav / 3600, (durationOfWav % 3600) / 60, durationOfWav % 60),
                                    Sysnumber3 = fileData.IMEI,
                                    //Event = 0,
                                    //Eventcode = "GSM",
                                    //Standard = "GSM_ABIS",
                                    //Network = null,
                                    //Sourceid = 0,
                                    //Status = 0,
                                    //Belong = null,
                                    //Dchannel = 2,
                                    //Rchannel = 2,
                                    Sourcename = sourceName,
                                    Talker = fileData.Talker,
                                    Usernumber = fileData.Caller,
                                    Calltype = fileData.Calltype
                                };

                            var data1TableEntry = new SPR_SP_DATA_1_TABLE
                                {
                                    Id = maxKey + 1,
                                    //Order = 1,
                                    //Recordtype = "PCMA",
                                    Fspeech = fileDataLeft, //тип данных OracleDbType.Blob, в OracleDbContext.cs (также для Rspeech)
                                    Rspeech = fileDataRight //modelBuilder.Entity<SPR_SP_DATA_1_TABLE>().ToTable("SPR_SP_DATA_1_TABLE").Property(b => b.Fspeech).HasColumnType("BLOB")

                                };

                            context.SprSpeechTable.Add(speechTableEntry);
                            context.SprSpData1Table.Add(data1TableEntry);

                            await context.SaveChangesAsync();                        
                             
                            message = "\n" + filePath + " - записан в БД." + message;
                        }
                    }
                    catch (DbUpdateException e)
                    {
                        message = "\n" + filePath + " - ошибка записи. " + e.Message + "\nInner Exception: " + e.InnerException?.Message + message;
                        foreach (var entry in e.Entries)
                        {
                            entry.State = EntityState.Detached;
                        }
                    }
                    catch (Exception ex)
                    {
                        message = "\n" + filePath + " - ошибка записи. " + ex.Message + message;
                    }

                    Console.WriteLine(DateTime.Now);
                }

                await context.Database.CloseConnectionAsync();
                message += "EFCore: Соединение с Oracle закрыто!\n";
                message += "Время выполнения: " + (DateTime.Now - DateTime.Now).ToString() + "\n";
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine("Error connecting or operating to Oracle: " + ex.Message);
            message = "Ошибка при выполнении операции с базой данных Oracle: " + ex.Message + "\n" + message;
        }
        // очистка директории после всех операций
        operations.clearFolder(pathToSaveTempAudio);
    }

    // т.е. в папке оригинал + 2 (или 1) + 1
    private async Task RunFFmpeg(string inputFileName)
    {
        var mediaInfo = await FFProbe.AnalyseAsync(inputFileName);
        durationOfWav = Convert.ToInt32(mediaInfo.PrimaryAudioStream?.Duration.TotalSeconds);
        Console.WriteLine("durationOfWav:" + durationOfWav);

        string ffmpegCommandParams;

        if (mediaInfo.PrimaryAudioStream?.Channels >= 2)
        {
            ffmpegCommandParams = $"-i {inputFileName} -filter_complex \"[0:0]pan=1|c0=c0[left];[0:0]pan=1|c0=c1[right]\" ";
            ffmpegCommandParams += $"-map \"[left]\" -c:a pcm_alaw -b:a 128k -ar 8000 {inputFileName}_left.wav ";
            ffmpegCommandParams += $"-map \"[right]\" -c:a pcm_alaw -b:a 128k -ar 8000 {inputFileName}_right.wav ";
        }
        else
        {
            ffmpegCommandParams = $"-i {inputFileName} -codec:a pcm_alaw -b:a 128k -ac 1 -ar 8000 {inputFileName}_mono.wav";
        }
        await RunCmdCommand(ffmpegExePath, ffmpegCommandParams);

    }

    private async Task RunCmdCommand(string executablePath, string command)
    {
        ProcessStartInfo startInfo = new ProcessStartInfo
            {
                FileName = "cmd.exe",
                RedirectStandardInput = true,
                RedirectStandardOutput = true,
                UseShellExecute = false,
                CreateNoWindow = true
            };

        using (Process process = new Process { StartInfo = startInfo })
        {
            process.OutputDataReceived += (sender, e) =>
            {
                if (!string.IsNullOrEmpty(e.Data))
                {
                    Console.WriteLine(e.Data);
                    InvokeAsync(() =>
                    {
                        string beforeTime = "->";
                        int indexOfTimePosition = e.Data.IndexOf(beforeTime);
                        if (indexOfTimePosition != -1)
                        {
                            string time = e.Data.Substring(indexOfTimePosition + beforeTime.Length, 8);
                            TimeSpan timeSpan = TimeSpan.Parse(time);
                            currentProgress = (int)(100 * timeSpan.TotalSeconds / durationOfWav);
                            currentProgress = currentProgress > 100 ? 99 : currentProgress;
                            Console.WriteLine($"Прогресс: {currentProgress}");
                        }
                        StateHasChanged();
                    });
                }
            };

            process.Start();

            using (StreamWriter sw = process.StandardInput)
            {
                if (sw.BaseStream.CanWrite)
                {
                    sw.WriteLine($"c: cd");
                    sw.WriteLine($"cd {Path.GetDirectoryName(executablePath)}");
                    sw.WriteLine($"{Path.GetFileName(executablePath)} {command}");
                    sw.WriteLine("exit");
                }
            }
            process.BeginOutputReadLine();
            await Task.Run(() => process.WaitForExit());
        }
    }

}
