@* Processor.razor *@

@rendermode InteractiveServer

@using Microsoft.EntityFrameworkCore
@using System.Text.Json
@using System.Net.Http
@using System.Text
@using System.ComponentModel

@using MudBlazorWeb2.Components.EntityFrameworkCore
@using MudBlazorWeb2.Components.Modules._Shared
@using MudBlazorWeb2.Components.Modules.WhOllProcessWithDb
@using MudBlazorWeb2.Components.Modules.WhOllProcessWithDb.Services
@using MudBlazorWeb2.Components.Modules.SettingsOper.Services

@inject StateService2 StateService2

@inject UserSettingsService UserSettingsService
@inject SettingsService SettingsService
@inject IConfiguration Configuration

@inject WhisperService whisper
@inject OllamaService ai

<MudText Style="position:relative;">

    <MudOverlay Visible="@StateService2.IsPlayingNow2" LightBackground="true" Absolute="true" />

    @*<OracleConnectionSettings colorButton="@colorTag" OnSettingsChanged="OnSettingsChanged" settingsDB="@settingsDB" oraItemsDB="@oraItemsDB" propertyName="SettingsProcessing" />*@
    <MudText Style="display:flex; padding-bottom: 15px;">
        Выбранная схема:&nbsp;<MudText Color="@colorTag">@Scheme</MudText>
    </MudText>
    <MudDivider /><br />

    <MudText Style="display: flex; justify-content:space-between; align-items:start; padding-bottom: 7px;">
        <MudText>
            @* // Период, Длительность *@
            <MudGrid Spacing="8" Justify="Justify.FlexStart">
                <MudItem>
                    <MudTextField T="DateTime" Format="s" Label="От даты:" InputType="InputType.DateTimeLocal" @bind-Value="@StateService2.StartDate2" />
                </MudItem>
                <MudItem>
                    <MudTextField T="DateTime" Format="yyyy-MM-ddTHH:mm:ss" Label="По дату:" InputType="InputType.DateTimeLocal" @bind-Value="@StateService2.EndDate2" />
                </MudItem>
                <MudItem style="max-width:180px">
                    <MudTextField T="string" Label="Длительность от:" @bind-Value="StateService2.TimeInterval2" />
                </MudItem>
            </MudGrid>

            @* // Повторный запуск *@
            <MudGrid Spacing="3" Justify="Justify.FlexStart">
                <MudItem>
                    <MudCheckBox @bind-Value="StateService2.IsCycle2" Size="Size.Small" Label="С интервалом повторного запуска (мин.):" Color="@colorTag" />
                </MudItem>
                <MudItem>
                    <MudNumericField Style="width:50px; top:7px;" @bind-Value="StateService2.CycleInterval2" Min="0" Step="1" Variant="Variant.Text" />
                </MudItem>
            </MudGrid>
        </MudText>

    </MudText>
</MudText>

<MudDivider />

<MudText Style="display:flex; align-items:center;">
    @* // Кнопки управления *@
    <MudIconButton Icon="@Icons.Material.Filled.PlayCircleFilled" Color="@colorTag" OnClick="PressStart2" Size="Size.Large" />
    <MudIconButton Icon="@Icons.Material.Filled.StopCircle" Color="@colorTag" OnClick="PressStop2" Size="Size.Large" />
    @* // Состояние выполнения *@
    @if (StateService2.IsPlayingNow2) // прогресс ProcessedKeys / TotalKeys
    {
        <MudText>&emsp;&emsp;</MudText>

        @if (!StateService2.IsStoped2)
        {
            <MudText>
                <MudProgressLinear Color="@colorTag" Indeterminate="true" Size="Size.Large" Style="width: 350px; margin-top: 12px;">
                    <MudText Typo="Typo.subtitle1" Color="Color.Default">
                        <b>Процесс: @StateService2.ProcessedKeys2 / @StateService2.TotalKeys2</b>
                    </MudText>
                </MudProgressLinear>
            </MudText>
        }
        else if (StateService2.IsCycle2) // повторный запуск
        {
            <MudText>
                Ожидание повторного запуска каждые @(StateService2.CycleInterval2 * 60) сек. &nbsp;&nbsp;&nbsp;
                <MudProgressCircular Color="@colorTag" Size="Size.Small" Indeterminate="true" />
            </MudText>
        }
    }

</MudText>
<MudText>@StateService2.ProcessingMessage2</MudText>

@code {

    [Parameter]
    public MudBlazor.Color colorTag { get; set; }
    [Parameter]
    public Settings settingsDB { get; set; }
    [Parameter]
    public OraItems oraItemsDB { get; set; } 
    [Parameter]
    public string propertyName { get; set; }
    [Parameter]
    public string Scheme { get; set; } = "sputnik";


    //private Settings settingsDB = null;

    //int lagTime = 0; // время запаздывания Ollama от Whisper
    //int ProcessedAi = 0; // количество выполненных Ollama

    protected override async Task OnInitializedAsync()
    {
        StateService2.PropertyChanged2 += StateService2_PropertyChanged;
        if (!Directory.Exists(Configuration["AudioPathForProcessing"])) Directory.CreateDirectory(Configuration["AudioPathForProcessing"]);
        await Task.Delay(1);
        //await LoadSettings();
    }

    private async Task LoadSettings2()
    {
        settingsDB = SettingsService.GetSettings();
        await Task.Delay(1);
    }

    private void StateService2_PropertyChanged(object sender, PropertyChangedEventArgs e) => InvokeAsync(StateHasChanged);

    private async Task PressStart2()
    {
        StateService2.IsStopPressed2 = false;
        if (StateService2.IsPlayingNow2)
        {
            StateService2.ProcessingMessage2 = "Обработка запущена, сначала выполните остановку.";
            return;
        }

        StateService2.ProcessingMessage2 = "Обработка запускается...";
        try
        {
            do
            {
                settingsDB = SettingsService.GetSettings();
                string conStringDBA = $"User Id={settingsDB.SettingsSputnik.OraItems.User};Password={settingsDB.SettingsSputnik.OraItems.Password};Data Source={settingsDB.SettingsSputnik.OraItems.DataSource};";
                string schemeName = Scheme;

                StateService2.ChangeState2(true, false, "Обработка запускается...", 0, 0); // IsPlayingNow, IsStoped...
                await RunAiForDbAudioAsync2(StateService2, schemeName, Configuration["OllamaModelName"], UpdateProgressWhOll2, conStringDBA);
                await Task.Delay(3000);
                StateService2.ChangeState2(true, true, $"Обработка завершена. Обработано: {StateService2.ProcessedKeys2} / {StateService2.TotalKeys2}"); // IsPlayingNow, IsStoped...

                if (StateService2.IsCycle2 && !StateService2.IsStopPressed2)
                {
                    StateService2.ProcessingMessage2 = "Обработка завершена. Ожидание новых записей...";
                    await Task.Delay(StateService2.CycleInterval2 * 60 * 1000);
                }

            }
            while (!StateService2.IsStopPressed2 && StateService2.IsCycle2);
            StateService2.IsPlayingNow2 = false;

        }
        catch (Exception ex)
        {
            StateService2.ChangeState2(false, true, $"Произошла ошибка: {ex.Message}");
            StateService2.IsStoped2 = true;
        }
    }

    private async Task PressStop2()
    {
        StateService2.IsStopPressed2 = true;
        StateService2.ProcessingMessage2 = StateService2.IsStoped2 ? "Обработка остановлена." : "Выполняется остановка, подождите...";
        while (StateService2.IsStoped2 == false)
        {
            await Task.Delay(1000);
        }
        StateService2.IsPlayingNow2 = false;
    }

    private async void UpdateProgressWhOll2(int processed, int total)
    {
        if (StateService2.ProcessedKeys2 < processed) StateService2.ProcessingMessage2 = "Обработка выполняется..."; // если процесс продолжается запираем ошибку
        StateService2.ProcessedKeys2 = processed;
        StateService2.TotalKeys2 = total;
        await InvokeAsync(() => StateHasChanged());
    }

    private async Task RunAiForDbAudioAsync2(StateService2 StateService2, string schemeName, string modelName, Action<int, int> updateProgress, string conStringDBA)
    {
        using (var db = new OracleDbContext(new DbContextOptionsBuilder<OracleDbContext>().UseOracle(conStringDBA).Options))
        {
            await db.Database.OpenConnectionAsync();
            await db.Database.ExecuteSqlRawAsync($"ALTER SESSION SET CURRENT_SCHEMA = {schemeName}");
            ConsoleCol.WriteLine($"RunAiForDbAudioAsync => Выбранная схема: {schemeName}", ConsoleColor.DarkCyan);

            var ignoreRecordTypes = Configuration.GetSection("AudioConverter:IgnoreRecordTypes").Get<List<string>>();
            // Получить список аудио по фильтру пользователя в StateService2(даты, интервал) и кодекам ignoreRecordTypes
            var audioList = await EFCoreQuery.GetSpeechRecords(StateService2.StartDate2, StateService2.EndDate2, StateService2.TimeInterval2, db, ignoreRecordTypes);

            int processedKeys = 0;
            //ProcessedAi = 0;

            int totalKeys = audioList.Count;

            foreach (var entity in audioList)
            {
                // Остановить процесс, если нажата кнопка
                if (StateService2.IsStopPressed2)
                {
                    StateService2.ChangeState2(false, true, $"Обработка завершена. Обработано: {StateService2.ProcessedKeys2} / {StateService2.TotalKeys2}", StateService2.ProcessedKeys2, StateService2.TotalKeys2); // IsPlayingNow, IsStoped...
                    break;
                }

                // Update Progress
                updateProgress(processedKeys, totalKeys);
                StateService2.IsStoped2 = false;
                StateService2.ProcessingMessage2 = "Обработка выполняется...";

                // ORACLE => get audio (left, right, recordType)
                var (audioDataLeft, audioDataRight, recordType) = await EFCoreQuery.GetAudioDataAsync(entity.Id, db);
                Console.WriteLine($"Audio data for key {entity.Id} loaded successfully. recordType = " + recordType);

                // PreText => get PreText for operator or PreTextDefault
                string preText = await GetPreTextForOperatorAsync2(entity.Sourcename);

                // FFMpeg or Decoder => audio to folder
                string audioFilePath = Path.Combine(Configuration["AudioPathForProcessing"], $"{entity.Id}.wav");
                bool result = await DbToAudioConverter.FFMpegDecoder(audioDataLeft, audioDataRight, recordType, audioFilePath, Configuration);
                if (!result) continue;

                // WHISPER
                Task<string> _recognizedText = whisper.RecognizeSpeechAsync(audioFilePath, Configuration); //асинхронно, не ждём
                (string languageCode, string detectedLanguage) = await whisper.DetectLanguageAsync(audioFilePath, Configuration);
                string recognizedText = await _recognizedText; //дожидаемся _recognizedText...

                // Temprorary push string to Notice to aviod repeated process with entity
                entity.Notice = "TempRecord";
                db.SprSpeechTable.Update(entity);
                await db.SaveChangesAsync();

                // Delete earlier created file
                Files.DeleteFilesByPath(audioFilePath);

                // OLLAMA + ORACLE => Run task !!!_WITHOUT await
                await ProcessOllamaAndUpdateEntityAsync2(entity.Id, recognizedText, languageCode, detectedLanguage, preText, Configuration["OllamaModelName"], schemeName, conStringDBA, Configuration, SettingsService, entity, db);

                // lag - задержка => если Ollama отстаёт от Whisper => ожидаем...
                //lagTime = await ApplyLagTimePause2(lagTime);

                // TODO
                // разрешить "вырываться вперёд не более чем на N раз" и ProcessedAi вывести в Прогресс + Singleton
                /*while (processedKeys - 10 > ProcessedAi)
                {
                    await Task.Delay(10000);
                }*/

                updateProgress(++processedKeys, totalKeys);
            }
            await db.Database.CloseConnectionAsync();
        }
    }

    // TODO "обнуление" Notice для какой-н БД

    private async Task ProcessOllamaAndUpdateEntityAsync2(long? entityId, string recognizedText, string languageCode, string detectedLanguage, string preText, string modelName, string schemeName, string conStringDBA, IConfiguration Configuration, SettingsService SettingsService, SPR_SPEECH_TABLE entity, OracleDbContext db)
    {
        // OLLAMA
        try
        {
            int lagTime;
            (string responseOllamaText, lagTime) = await ai.OllamaResponse(preText, recognizedText, modelName, Configuration);
            if (languageCode != "ru" && languageCode != "uk" && !string.IsNullOrEmpty(languageCode))
            {
                (recognizedText, lagTime) = await ai.OllamaTranslate(recognizedText, modelName, languageCode, detectedLanguage, Configuration, SettingsService);
            }
            await EFCoreQuery.InsertCommentAsync(entityId, recognizedText, detectedLanguage, responseOllamaText, modelName, schemeName, conStringDBA);
            //ProcessedAi++;
            //ConsoleCol.WriteLine("ProcessedAi = " + ProcessedAi, ConsoleColor.Yellow);
        }
        catch (Exception ex)
        {
            // EFCoreQuery - "обнуление" Notice при ошибке
            await EFCoreQuery.UpdateNoticeValueAsync(entityId, schemeName, conStringDBA, null);
            Console.WriteLine("Ошибка при обработке Ollama и обновлении сущности EFCore: " + ex.Message);
            // TODO if (MistakesCount > 10)
            //StateService2.IsStopPressed = true;
        }

    }

    private async Task<string> GetPreTextForOperatorAsync2(string operatorName)
    {
        await Task.Delay(1);
        ConsoleCol.WriteLine("operatorName: " + operatorName, ConsoleColor.DarkYellow);
        string preText = "";

        try
        {
            preText = await UserSettingsService.ReadItemValueByKey(operatorName);
            if (string.IsNullOrEmpty(preText))
            {
                preText = SettingsService.GetSettings().PreTextDefault;
            }

        }
        catch (Exception ex)
        {
            ConsoleCol.WriteLine("Error getting Operator: " + ex, ConsoleColor.Red);
            preText = SettingsService.GetSettings().PreTextDefault;
        }
        finally
        {
            ConsoleCol.WriteLine("preText: " + preText, ConsoleColor.DarkYellow);
        }
        return preText;
    }

    /*private async Task<int> ApplyLagTimePause2(int delay)
    {
        if (delay <= 50)
        {
            ConsoleCol.WriteLine($"lagTime = {delay}", ConsoleColor.Yellow);
            return delay;
        }
        ConsoleCol.WriteLine($"lagTime = {delay} выжидаем паузу... {delay / 2} секунд...", ConsoleColor.Yellow);
        await Task.Delay(delay / 2 * 1000);
        if (delay == lagTime) return delay / 2;
        else return lagTime;
    }*/

    private async Task OnSettingsChanged2()
    {
        //await LoadSettings();
        await Task.Delay(1);
        Console.WriteLine("Настройки подключения к БД для Процесса обработки изменились");
    }
}