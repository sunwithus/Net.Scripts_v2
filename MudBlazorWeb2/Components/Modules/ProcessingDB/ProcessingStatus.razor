@* ProcessingStatus.razor *@

@using Microsoft.EntityFrameworkCore
@using MudBlazorWeb2.Components.EntityFrameworkCore
@using System.Net.Http;
@using System.Text;

@inject IDbContextFactory<OracleDbContext> DbFactory
@inject WhisperService whisper
@inject OllamaService ai

<MudText>
    @* // Кнопки управления *@
    <MudIconButton style="width: 48px; height: 48px" Icon="@Icons.Material.Filled.PlayCircleFilled" Color="@colorTag" OnClick="StartProcessingDB" />
    <MudIconButton style="width: 48px; height: 48px" Icon="@Icons.Material.Filled.StopCircle" Color="@colorTag" OnClick="StopProcessing" />
    @* // Состояние выполнения *@
    <MudText>@ProcessSingleton.Instance.ProcessingMessage</MudText>
    <MudProgressLinear Color="@colorTag" Indeterminate="true" Size="Size.Large" Style="width: 350px;">
        <MudText Typo="Typo.subtitle1" Color="Color.Default">
            <b>Процесс: @ProcessSingleton.Instance.ProcessedKeys / @ProcessSingleton.Instance.TotalKeys</b>
        </MudText>
    </MudProgressLinear>
    <MudText>
        Ожидание повторного запуска каждые @(ProcessSingleton.Instance.CycleInterval * 60) сек. &nbsp;&nbsp;&nbsp;
        <MudProgressCircular Color="@colorTag" Size="Size.Small" Indeterminate="true" />
    </MudText>
</MudText>


@code {
    [Parameter]
    public MudBlazor.Color colorTag { get; set; } = MudBlazor.Color.Secondary;
    [Parameter]
    public string preText { get; set; } = "Напиши краткое содержание текста: ";
    [Parameter]
    public string modelName { get; set; } = "gemma2";
    [Parameter]
    public string schemeName { get; set; } = "test";
    [Parameter]
    public string conStringDBA { get; set; } = "";
    [Parameter]
    public string pathFileForAudio { get; set; } = "";


    private async Task StartProcessingDB()
    {
        if (ProcessSingleton.Instance.IsPlayingNow)
        {
            ProcessSingleton.Instance.ProcessingMessage = "Обработка запущена, сначала выполните остановку.";
            return;
        }

        ProcessSingleton.Instance.ProcessingMessage = "Обработка запущена...";
        await InvokeAsync(() => StateHasChanged());

        try
        {
            do
            {
                ProcessSingleton.Instance.IsPlayingNow = true;
                await ProcessAudioAsync(ProcessSingleton.Instance.StartDate, ProcessSingleton.Instance.EndDate, schemeName, modelName, preText, UpdateProgress);
                ProcessSingleton.Instance.ProcessingMessage = $"Всего обработано: {ProcessSingleton.Instance.ProcessedKeys} / {ProcessSingleton.Instance.TotalKeys}";
                if (ProcessSingleton.Instance.IsCycle && !ProcessSingleton.Instance.IsStopPressed)
                {
                    await Task.Delay(ProcessSingleton.Instance.CycleInterval * 60 * 1000); 
                }
            }
            while(!ProcessSingleton.Instance.IsStopPressed);
            ProcessSingleton.Instance.IsPlayingNow = false;

        }
        catch (Exception ex)
        {
            ProcessSingleton.Instance.ProcessingMessage = $"Произошла ошибка: {ex.Message}";
        }
    }

    private void StopProcessing()
    {
        ProcessSingleton.Instance.IsStopPressed = true;
        ProcessSingleton.Instance.ProcessingMessage = $"Выполняется остановка, подождите...";
    }


    public async void UpdateProgress(int processed, int total)
    {
        if (ProcessSingleton.Instance.ProcessedKeys < processed) ProcessSingleton.Instance.ProcessingMessage = "Обработка запущена..."; // если процесс продолжается запираем ошибку
        ProcessSingleton.Instance.ProcessedKeys = processed;
        ProcessSingleton.Instance.TotalKeys = total;
        await InvokeAsync(() => StateHasChanged());
    }

    public async Task ProcessAudioAsync(DateTime StartDate, DateTime EndDate, string schemeName, string modelName, string preText, Action<int, int> updateProgress)
    {

        using (var db = new OracleDbContext(new DbContextOptionsBuilder<OracleDbContext>().UseOracle(conStringDBA).Options))
        {
            await db.Database.OpenConnectionAsync();
            await db.Database.ExecuteSqlRawAsync($"ALTER SESSION SET CURRENT_SCHEMA = {schemeName}");
            Console.WriteLine($"Выбранная схема: {schemeName}");

            long? maxKey = await db.SprSpeechTable.MaxAsync(x => (long?)x.Id) ?? 0;
            var audioList = db.SprSpeechTable.Where(x => x.Datetime >= StartDate && x.Datetime <= EndDate)
                                             .OrderByDescending(x => x.Datetime).ToList();

            int processedKeys = 0;
            int totalKeys = audioList.Count;
            updateProgress(processedKeys, totalKeys);

            foreach (var entity in audioList)
            {
                var (audioDataLeft, audioDataRight, recordType) = await EFCoreLinq.GetAudioDataAsync(entity.Id, schemeName, db);
                if (audioDataLeft != null) Console.WriteLine($"Audio data for key {entity.Id} loaded successfully. recordType = " + recordType);

                if (!Path.Exists(pathFileForAudio)) Directory.CreateDirectory(pathFileForAudio);
                string audioFilePath = Path.Combine(pathFileForAudio, $"{entity.Id}.wav");
                Console.WriteLine("audioFilePath: " + audioFilePath);
                if (EncodingDecoding._tempIgnoreRecordType.Contains(recordType)) continue; // пока с этими кодеком не работаем, а также BINARY, FAX...

                if (recordType != null && EncodingDecoding._codecs.Contains(recordType))
                {
                    Console.WriteLine("using decoder!!!");
                    await EncodingDecoding.ConvertToWavUsingDecoder(audioDataLeft, audioDataRight, audioFilePath, recordType);
                    await Task.Delay(200); //возможно файл не успевает сохраниться, поэтому пауза
                }
                else
                {
                    Console.WriteLine("using ffmpeg!!!");
                    Console.WriteLine("recordType is " + recordType);
                    await EncodingDecoding.ConvertToWavAsyncStream(audioDataLeft, audioDataRight, audioFilePath);
                    await Task.Delay(200); //возможно файл не успевает сохраниться, поэтому пауза
                }

                string[] recognizedLanguage = new string[] { "", "" };
                string recognizedText = "";
                string languageCode = "";
                string detectedLanguage = "";

                // Максимальное количество попыток
                const int maxRetries = 2;
                int currentAttempt = 0;
                bool success = false;
                //Произошла ошибка на определении языка: Error while copying content to a stream.
                //при повторном запуске в этом же месте ошибка может не произойти
                //поэтому выполняем несколько попыток

                /*while (currentAttempt < maxRetries && !success)
                {
                    try
                    {
                        recognizedLanguage = await whisper.DetectLanguageAsync(audioFilePath);
                        languageCode = recognizedLanguage[0].ToLower();
                        detectedLanguage = recognizedLanguage[1];

                        Console.WriteLine($"Detected language: {languageCode} ({detectedLanguage})");

                        recognizedText = await whisper.RecognizeSpeechAsync(audioFilePath, languageCode);
                        Console.WriteLine($"Recognized text: {recognizedText}");

                        success = true;
                    }
                    catch (Exception ex)
                    {
                        currentAttempt++;
                        if (currentAttempt >= maxRetries)
                        {
                            // Логируем ошибку, если все попытки не удались
                            Console.WriteLine($"Ошибка при обработке entity.Id (INC_KEY): {entity.Id}: {ex.Message}");
                        }
                        else
                        {
                            // Ждем перед повторной попыткой
                            await Task.Delay(300);
                        }
                    }
                }*/

                languageCode = "en";
                detectedLanguage = "english";
                string responseOllamaText = "Аудио не транскрибировано";
                recognizedText = "Test Test Test" + responseOllamaText;
                /*if (recognizedText != "")
                {
                    responseOllamaText = await ai.SendTextForAnalysisAsync(preText, recognizedText, modelName);
                    if (languageCode != "ru" && languageCode != "uk")
                    {
                        string preTextToTranslate = "Сделай перевод текста на русский язык, ответом должен должен быть только перевод, без дополнительных фраз. Вот текст: ";
                        recognizedText = await ai.SendTextForAnalysisAsync(preTextToTranslate, recognizedText, modelName);
                        recognizedText = $"Перевод с {detectedLanguage.ToUpper()} языка: \n" + recognizedText;
                    }
                }*/

                await EFCoreLinq.InsertCommentAsync(entity.Id, recognizedText, detectedLanguage, responseOllamaText, db, schemeName, modelName);
                File.Delete(audioFilePath);
                
                processedKeys++;
                updateProgress(processedKeys, totalKeys);

            }
        }
    }

    

}